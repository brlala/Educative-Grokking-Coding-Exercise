# You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly
# connected to the jth node if graph[i][j] == 1.
#
# Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one
# of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will
# continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of
# malware stops. We will remove exactly one node from initial.
#
# Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(
# initial), return such a node with the smallest index.
#
# Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to
# the malware spread.
class Solution:
    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        """
        https://leetcode.com/problems/minimize-malware-spread/discuss/181186/python-dfs-solution-with-picture-to-explain-my-thought(with-extra-Chinese-explanation)

        Complexity O(n) since all nodes will only be traverse once
        """
        def dfs(node, vis):
            for v in range(len(graph[node])):
                if graph[node][v] == 1 and v not in vis:
                    vis.add(v)
                    dfs(v, vis)

        initially_infected = set(initial)
        subgraph_len = 0
        t_vis = set()
        del_node = min(initial)

        for node in range(len(graph)):
            if node not in t_vis:
                vis = {node}
                dfs(node, vis)
                # calculate the number of infected node in the subgraph
                infected = vis & initially_infected
                if len(infected) == 1:
                    # more number of nodes or smaller index
                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infected)[0] < del_node):
                        del_node, subgraph_len = list(infected)[0], len(vis)
                t_vis |= vis
        return del_node
    a = []
    a.sort()
    a.reverse()


a = Solution()
print(a.minMalwareSpread([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]], [3, 1]))
